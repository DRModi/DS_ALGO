(1) Dynamic Array: get and set the value at given index in Array is the KILLER FEATURE. BigO(1)
************************************************************************************************
size= Number of the element contain in the array
index = current element position in the array

- Resize: compare with initial capacity,
          create new array with double the initial capacity,
          copy existing array to newly created array,
          point old to new,
          set new initial capacity
- insertion, first check resize needed, move up the element (size count start 1 + index count start 0)
    size = size-1, size --;
    Note: start with end of array, move up last element to next location.
    Increment size counter for addition.
    It take - Linear time O(n)
- Deletion move down the element (size count start 1 + index count start 0)
    index = index+1, index<size-1; index++
    Decrement the size counter for deletion.
    Note: start with index of array, move down next element to over current index location.
    It take - Linear time O(n)

(2) Linked List: Ability to insert and delete in constant time at the beginning, is the KILLER Feature. BigO(1)
***************************************************************************************************************
- Size/Count can be retrieve using two way:
    (1) Have internal tracking counter, which increment/decrements based on insert/delete operation
        Time complexity O(1) constant time (same operation of reading size variable)
        Space complexity O(1) for creating internal variable (need to check it can be 0 since it is not created part of counting)

    (2) Iterate through list and count it:
        Time complexity O(n) linear time (since need to iterate list till nexelement pointer have null value)
        Space complexity O(1) for creating internal variable to store count value

- Insertion, at the begging BigO(1) Constant: , otherwise O(n):
            * (1) create new node,
            * (2) Check if it is the first ever node then set as head
            * (3) if 2 is not applicable, then point new node to head
            * (4) set head as new node.

- Deletion, at begging BigO(1), otherwise O(n):
       * (1) head is null or size 0, just return
       * (2) if head being removed then, head.nextElement become head
       * (3) if 2 is not possible, then for middle element where we move nextElement.nextElement twice



(3) Stacks and Queue: Ability to push & pop (Stacks) and add & remove (Queues), is the KILLER features. BigO(1)
implementation with Linked List which is often used. It can be implemented using array.
*****************************************************************************************************************
Created using linked list

Stacks:
 - Created using linked list - Using only head element
 - Remember LIFO - Last in first out
 - Function - push, pop, peek, isEmpty
 - Killer Feature [insertion and deletion O(1), search and access is O(n)]

Queue:
 - Created using linked list - Using both head (to remove node) and tail (to add the node) element
 - Remember LIFO - Last in first out
 - Function - add, remove, peek, isEmpty
 - Killer Feature [insertion and deletion O(1), search and access is O(n)]


(4) HashTable:
*****************************************************************************************************************


(5) Binary tree:
**********************
(1) Insert in binary tree:
    two way - First recursively and iteratively
        - Find position/null node based on the key value, either root, left or right
            Recursively - if(key<currentNode.key)
                node.leftNode = recursiveFun (currentNode.leftNode, Key, Value)
            Iteratively - if(key<currentNode.key)
                if currentNode.leftNode = null ? currentNode = newNode : currentNode = currentNode.leftNode;

        - Create new node and assign it to the null position which found in earlier step

(2) Find in binary tree:
    two way - First recursively and iteratively
            - Find position/null node based on the key value, either root, left or right
                Recursively - if(key<currentNode.key)
                    return recursiveFun (currentNode.leftNode, Key, Value)
                Iteratively - if(key<currentNode.key)
                    if currentNode.leftNode = null ? null : currentNode = currentNode.leftNode;
            - Create new node and assign it to the null position which found in earlier step


  // Delete: Three cases
    // 1. No child
    // 2. One child
    // 3. Two children

    // First two are simple. Third is more complex.

    // Case 1: No child - simply remove from tree by nulling it.
    //
    // Case 2: One child - copy the child to the node to be deleted and delete the child

    // Case 3: Two children - re-gig the tree to turn into a Case 1 or a Case 2

    // For third case we first need to
    // 1. Find the right side min
    // 2. Copy it to the node we want to delete (creating a duplicate)
    // 3. Then delete the min value way down on the branch we just copied
    //
    // This works because you can represent a binary tree in more than one way.
    // Here we are taking advantage of that fact to make our more complicated
    // 3rd case delete more simple by transforming it into case 1.